"""
Sort Comparison
"""
import argparse
import os
import sys
from typing import Optional, Tuple
import operator
from pathlib import Path
from Compiler import types, library, instructions, sorting

MATCH_KEYS = 0
IS_TRIGGER = 1
VALUE = 2
BREAKDOWN_KEY = 3

RADIX_SORT = 0
BIT_RADIX_SORT = 1
BATCHER_SORT = 2
LIBRARY_SORT = 3  # we used this for PATCG benchmarks 
TWO_BIT_RADIX_SORT = 4 # this is @algebravic's optimized version
THREE_BIT_RADIX_SORT = 5

def print_property(fun, vec, msg):

    print_ln("%s: %s", msg, tree_reduce(operator.add,fun(vec)).reveal())

def set_directory() -> None:

    source_dir = os.getcwd() + '/Programs/Source'
    sys.path = [source_dir] + sys.path

def reconstruct(bit_array: Matrix) -> Array:
    """
    bit_array is an N by B array of bits
    compute the integer representation.
    This should only involve scalar multiplies and adds.
    """

    num, n_bits = bit_array.sizes
    result = Array(num, sint)
    result.assign_vector(bit_array.get_column(n_bits - 1))
    for ind in range(n_bits - 2, -1, -1):
        result = result + result + bit_array.get_column(ind)
    return result

def validate_bits(arr: Array) -> Tuple[sint, sint]:
    """
    Test a purported bit vector.
    """

    small = arr.get_vector() < 0
    big = arr.get_vector() > 1

    return (tree_reduce(operator.add, small),
            tree_reduce(operator.add, big))

def get_args(args) -> argparse.Namespace:
    """
    Get the arguments from the remainder of compile.py command line.
    """

    # It turns out that you *can* get arguments from the compile.py
    # command.  The arguments are everything after the name
    # of the file to be compiled.
    # Note that these arguements get added to the of the compiled file, 
    # e.g.:  ../../MP-SPDZ/compile.py -C -R 32 vectorized 8 4 32 
    # outputs the file: vectorized-8-4-32

    arg_parser = argparse.ArgumentParser("Attribution Benchmark")
    arg_parser.add_argument("numrows_power", type=int, default = 4,
                            nargs = '?',
                            help="Power of 2 for number of Rows")
    arg_parser.add_argument("n_bits", type = int, default = 32,
                            nargs = '?',
                            help="n_bits?")
    arg_parser.add_argument("sort_type", type = int,
                            default = LIBRARY_SORT,
                            nargs = '?',
                            help="sort_type")

    return arg_parser.parse_args(args)


def main():
    """
    Do the main processing.
    """

    set_directory()
    from asort import bit_radix_sort, radix_sort
    args = get_args(program.args[1: ])
    print(f"args = {args}")

    numrows = 2 ** args.numrows_power

    # load the data

    reports = Matrix(numrows, 4, sint)
    reports.assign_vector(sint.get_input_from(0, size = numrows * 4))

    match_keys = reports.get_column(MATCH_KEYS)
    # Now do the sort
    sorter = {LIBRARY_SORT: lambda mkeys, reps:
              sorting.radix_sort(mkeys, reports, n_bits = args.n_bits),
              RADIX_SORT: lambda mkeys, reps:
              radix_sort(mkeys, reps, n_bits = args.n_bits),
              TWO_BIT_RADIX_SORT: lambda mkeys, reps:
              radix_sort(mkeys, reps, n_bits = args.n_bits, chunk = 2),
              THREE_BIT_RADIX_SORT: lambda mkeys, reps:
              radix_sort(mkeys, reps, n_bits = args.n_bits, chunk = 3),
              BATCHER_SORT: lambda mkeys, reps:
              print("Batcher not implemented")}


    sort_fn = sorter.get(args.sort_type,
                         lambda mkeys, reps:
                         print(f"Illegal sort type {args.sort_type}"))
    sort_fn(match_keys, reports)


    for i in range(numrows):
        print_ln("%s ",reports[i].reveal())


    
main()

